%package list
\documentclass{article}
\usepackage[top=3cm, bottom=3cm, outer=3cm, inner=3cm]{geometry}
\usepackage{graphicx}
\usepackage{forest}
\usepackage{url}
\usepackage{pgfplots}
\pgfplotsset{compat=1.16}
%\usepackage{cite}
\usepackage{hyperref}
\usepackage{array}
\usepackage{multicol}
\newcolumntype{x}[1]{>{\centering\arraybackslash\hspace{0pt}}p{#1}}
\usepackage{natbib}
\usepackage{pdfpages}
\usepackage{multirow}
\usepackage{float}
\usepackage[normalem]{ulem}
\useunder{\uline}{\ul}{}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\csemail}{vmachacaa@unsa.edu.pe}
\newcommand{\csdocente}{Vicente Machaca Arceda}
\newcommand{\cscurso}{Algoritmos y Estructura de Datos}
\newcommand{\csuniversidad}{Universidad Nacional de San Agustín}
\newcommand{\csescuela}{Maestría en Ciencia de la Computación}
\newcommand{\cspracnr}{01}
\newcommand{\cstema}{Análisis de algoritmos}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\usepackage[english,spanish]{babel}
\usepackage[utf8]{inputenc}
\AtBeginDocument{\selectlanguage{spanish}}
\renewcommand{\figurename}{Figura}
\renewcommand{\refname}{Referencias}
\renewcommand{\tablename}{Tabla} 
\AtBeginDocument{
	\renewcommand\tablename{Tabla}
}

\usepackage{fancyhdr}
\usepackage{tabularx}
\usepackage{tikz-qtree}
\usepackage{tikz}
\usetikzlibrary{arrows.meta,bending}
\tikzset{every tree node/.style={minimum width=2.5em,draw,circle},
     blank/.style={draw=none},
     edge from parent/.style=
     {draw, edge from parent path={(\tikzparentnode) -- (\tikzchildnode)}},
     level distance=1.5cm}
\pagestyle{fancy}
\fancyhf{}
\setlength{\headheight}{30pt}
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\footrulewidth}{1pt}
\fancyhead[L]{\raisebox{-0.2\height}{\includegraphics[width=3cm]{img/logo_unsa}}}
\fancyhead[C]{}
\fancyhead[R]{\fontsize{7}{7}\selectfont	\csuniversidad \\ \csescuela \\ \textbf{\cscurso} }
\fancyfoot[L]{MSc. Vicente Machaca}
\fancyfoot[C]{\cscurso}
\fancyfoot[R]{Página \thepage}


\begin{document}
	
	\vspace*{10px}
	
	\begin{center}	
		\fontsize{17}{17} \textbf{ Práctica \cspracnr}
	\end{center}
	%\centerline{\textbf{\underline{\Large Título: Informe de revisión del estado del arte}}}
	%\vspace*{0.5cm}
	

	\begin{table}[h]
		\begin{tabular}{|x{4.7cm}|x{4.7cm}|x{4.7cm}|}
			\hline 
			\textbf{DOCENTE} & \textbf{CARRERA}  & \textbf{CURSO}   \\
			\hline 
			\csdocente & \csescuela & \cscurso    \\
			\hline 
		\end{tabular}
	\end{table}	
	
	
	\begin{table}[h]
		\begin{tabular}{|x{4.7cm}|x{4.7cm}|x{4.7cm}|}
			\hline 
			\textbf{PRÁCTICA} & \textbf{TEMA}  & \textbf{DURACIÓN}   \\
			\hline 
			\cspracnr & \cstema & 3 horas   \\
			\hline 
		\end{tabular}
	\end{table}
	
	
	\section{Datos de los estudiantes}
	\begin{enumerate}
		\item \textbf{Grupo:} 09
		\item \textbf{Integrantes:}
		\begin{itemize}
			\item Asmat Fuentes, Franz Rogger
			\item Esthela Espinoza, Fausto Danilo
			\item Ojeda Mamani, Abel Eberth
			\item Paredes Rodriguez, Raybert
		\end{itemize}		
	\end{enumerate}
	
	\section{Ejercicios}\label{sec:ejercicios}
	\begin{enumerate}
        \item \textbf{QuickSort:} 
            Quick sort
        \item \textbf{MergeSort:}
            Merge Sort
        \item \textbf{BucketSort:}
            Bucket Sort
        \item \textbf{HeapSort:}
            "El tiempo de ejecución de heapsort es \emph{O(n lg n)}. Al igual que la ordenación por inserción, pero a diferencia de la ordenación por fusión, la ordenación por montón ordena en el lugar: solo se almacena una cantidad constante de elementos de matriz fuera de la matriz de entrada en cualquier momento. Por lo tanto, heapsort combina los mejores atributos de estos dos algoritmos de clasificación.\par
            
            Heapsort también presenta otra técnica de diseño de algoritmos: usar una estructura de datos, en este caso una que llamamos "montón" (heap), para administrar la información. La estructura de datos del montón no solo es útil para heapsort, sino que también crea una cola de prioridad eficiente". \cite{cormen2022} \par

            El funcionamiento del algoritmo es generar un árbol binario para el array, se comparan los elementos padre de cada nodo (que contenga hijos) y se verifica que ambos hijos sean menores que el nodo padre, de no cumplirse esta regla se procede a realizar un intercambio del valor mayor con el padre. Se procede de forma consecutiva hasta tener el elemento de mayor valor hasta la cima, una vez obtenido se intercambia con el ultimo elemento y se vuelve a repetir el proceso hasta que el array se encuentre ordenado.\par

            \textbf{Ejemplo}
            Teniendo el siguiente array:

            %\centering
            \begin{tabularx}{0.8\textwidth} { 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X | }
                \hline
                    \textbf{3} & \textbf{7} & \textbf{5} & \textbf{2} & \textbf{4} & \textbf{6} & \textbf{9} & \textbf{1} & \textbf{8} \\
                \hline
                    0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\
                \hline
            \end{tabularx}

            En base a este array se genera el siguiente árbol

            \begin{tikzpicture}
              [level distance=10mm,
               every node/.style={circle,draw,inner sep=2mm},
               level 1/.style={sibling distance=25mm},
               level 2/.style={sibling distance=15mm},
               level 3/.style={sibling distance=15mm}]
              \node {3}
                 child {node {7}
                   child {node {2}
                     child {node {1}}
                     child {node {8}}
                   }
                   child {node {4}}
                 }
                 child {node {5}
                   child {node {6}}
                   child {node {9}}
                 };
            \end{tikzpicture}

        Se encuentra el ultimo nodo padre, en el ejemplo "2", Los elementos se ubican de la siguiente forma: (siendo i el índice del elemento a evaluar y n el numero de elementos del array):\par
        
        \textbf{Nodo padre}
        \[ Padre = i/2 \]
        \textbf{Nodo hijo izquierda (azul)}
        \[ Izquierda = 2i \]
        \textbf{Nodo hijo derecha (rojo)}
        \[ Derecha = 2i+1 \]

        \begin{tikzpicture}
            [level distance=10mm,
                every node/.style={circle,draw,inner sep=2mm},
                level 1/.style={sibling distance=25mm},
                level 2/.style={sibling distance=15mm},
                level 3/.style={sibling distance=15mm}]
          \node {3}
             child {node {7}
               child {node [fill=yellow] {2}
                 child {node [fill=blue!50] {1}}
                 child {node [fill=red!50] {8}}
               }
               child {node {4}}
             }
             child {node {5}
               child {node {6}}
               child {node {9}}
             };
        \end{tikzpicture}
        
        Una vez ubicado el ultimo nodo padre se procede a aplicar la regla que ambos hijos deben ser menores al valor del padre, en el ejemplo no se cumple con la regla (2, el padre, es menor que 8, uno de los hijos), por lo tanto, se debe intercambiar de los hijos el nodo con valor mayor (8), quedando de la siguiente forma:

        \begin{tikzpicture}
            [level distance=10mm,
               every node/.style={circle,draw,inner sep=2mm},
               level 1/.style={sibling distance=25mm},
               level 2/.style={sibling distance=15mm},
               level 3/.style={sibling distance=15mm}]
          \node {3}
             child {node {7}
               child {node [fill=lightgray] {\textbf{8}}
                 child {node {1}}
                 child {node [fill=lightgray] {\textbf{2}}}
               }
               child {node {4}}
             }
             child {node {5}
               child {node {6}}
               child {node {9}}
             };
        \end{tikzpicture}

        Este proceso se repite para todos los nodos padres del árbol (8, 7, 5 y 3), finalmente el árbol terminaría de la siguiente forma:

        \begin{tikzpicture}
            [level distance=10mm,
               every node/.style={circle,draw,inner sep=2mm},
               level 1/.style={sibling distance=25mm},
               level 2/.style={sibling distance=15mm},
               level 3/.style={sibling distance=15mm}]
          \node [fill=lightgray] {9}
             child {node [fill=lightgray] {8}
               child {node [fill=lightgray] {\textbf{7}}
                 child {node {1}}
                 child {node [fill=lightgray] {\textbf{2}}}
               }
               child {node {4}}
             }
             child {node [fill=lightgray] {3}
               child {node {6}}
               child {node [fill=lightgray] {5}}
             };
        \end{tikzpicture}

        Como se puede observar en la imagen, el mayor queda en la cima del árbol, quedando el array de esta forma:

            \begin{tabularx}{0.8\textwidth} { 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X | }
                \hline
                    \textbf{9} & \textbf{8} & \textbf{3} & \textbf{7} & \textbf{4} & \textbf{6} & \textbf{5} & \textbf{1} & \textbf{2} \\
                \hline
                    0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\
                \hline
            \end{tabularx}

        El siguiente paso es intercambiar el primer elemento con el último

            \begin{tabularx}{0.8\textwidth} { 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X | }
                \hline
                    \textbf{2} & \textbf{8} & \textbf{3} & \textbf{7} & \textbf{4} & \textbf{6} & \textbf{5} & \textbf{1} & \textbf{9} \\
                \hline
                    0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\
                \hline
            \end{tabularx}

            Se repite el proceso sin incluir el ultimo elemento (o los elementos ordenados en cada iteración)
        \end{enumerate}
            
    \section{Ejecución}\label{sec:ejecucion}
            \begin{enumerate}
                \item \textbf{QuickSort:} 
                    Quick sort
                \item \textbf{MergeSort:}
                    Merge Sort
                \item \textbf{BucketSort:}
                    Bucket Sort
                \item \textbf{HeapSort:}
                
                Comparación de ejecución entre lenguajes, en la ssiguientes tablas se muestran los tiempos de ejecución en los lenguales Python, Go y C++, en las mismas se expresa el tiempo (en milisegundos) y la cantidad de datos que se usaron en casda ejeción (expresado en miles).
                
                \textbf{C++}
                
                \begin{tabularx}{0.95\textwidth} { 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X | }
                \hline
                    \textbf{Ejec} & \textbf{10M} & \textbf{20M} & \textbf{30M} & \textbf{40M} & \textbf{50M} & \textbf{60M} & \textbf{70M} & \textbf{80M} & \textbf{90M} & \textbf{100M} \\
                \hline
                    1 & 6 & 11 & 18 & 24 & 30 & 37 & 43 & 50 & 58 & 63 \\ 
                    2 & 5 & 12 & 18 & 24 & 31 & 37 & 44 & 50 & 58 & 65 \\ 
                    3 & 5 & 12 & 17 & 24 & 30 & 37 & 45 & 51 & 56 & 63 \\ 
                    4 & 5 & 10 & 17 & 23 & 31 & 37 & 43 & 50 & 58 & 64 \\ 
                    5 & 5 & 13 & 17 & 23 & 29 & 37 & 43 & 50 & 58 & 67 \\ 
                    6 & 5 & 11 & 18 & 24 & 29 & 38 & 44 & 51 & 56 & 64 \\ 
                    7 & 5 & 11 & 17 & 24 & 30 & 39 & 44 & 51 & 56 & 63 \\ 
                    8 & 6 & 11 & 18 & 23 & 30 & 37 & 43 & 51 & 56 & 65 \\ 
                    9 & 5 & 11 & 17 & 23 & 30 & 37 & 44 & 51 & 58 & 65 \\ 
                    10 & 6 & 12 & 17 & 23 & 30 & 37 & 43 & 51 & 57 & 66 \\ 
                \hline
                \end{tabularx}
                
                \textbf{GO}
                
                \begin{tabularx}{0.95\textwidth} { 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X | }
                \hline
                    \textbf{Ejec} & \textbf{10M} & \textbf{20M} & \textbf{30M} & \textbf{40M} & \textbf{50M} & \textbf{60M} & \textbf{70M} & \textbf{80M} & \textbf{90M} & \textbf{100M} \\
                \hline
                    1 & 1.8 & 3.5 & 5.3 & 8.6 & 10.3 & 13.6 & 18.4 & 18.6 & 21.1 & 23.4 \\
                    2 & 1.6 & 3.5 & 5.2 & 8.5 & 10.2 & 14.3 & 20.5 & 18.6 & 22.1 & 23.4 \\
                    3 & 1.6 & 3.2 & 5.1 & 8.3 & 10.9 & 14 & 17.2 & 20.3 & 21.7 & 23.2 \\ 
                    4 & 1.7 & 4.5 & 5.3 & 8.2 & 10.6 & 13.8 & 16.7 & 18.9 & 21.8 & 22.4 \\
                    5 & 1.7 & 3.8 & 5.6 & 8.7 & 10.2 & 14.6 & 16.2 & 20.1 & 22.8 & 25 \\ 
                    6 & 1.6 & 4.1 & 5.2 & 8.6 & 11.3 & 13.2 & 17.1 & 17.7 & 20.5 & 23.4 \\
                    7 & 1.5 & 3.3 & 5 & 9.1 & 10.9 & 14.4 & 21.2 & 18.3 & 21.9 & 25.8 \\ 
                    8 & 1.7 & 3.2 & 5.4 & 8.7 & 10.9 & 13 & 21.6 & 19.5 & 21 & 23.6 \\ 
                    9 & 1.7 & 4.7 & 5.1 & 8.1 & 11 & 13.1 & 17.2 & 18.5 & 21.3 & 22.3 \\ 
                    10 & 1.7 & 4.6 & 5.2 & 8.6 & 10.2 & 13.5 & 14.9 & 19.6 & 21.3 & 23.6 \\ 

                \hline
                \end{tabularx}
                
                \textbf{Python}
                
                \begin{tabularx}{0.95\textwidth} { 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X 
                  | >{\centering\arraybackslash}X | }
                \hline
                    \textbf{Ejec} & \textbf{10M} & \textbf{20M} & \textbf{30M} & \textbf{40M} & \textbf{50M} & \textbf{60M} & \textbf{70M} & \textbf{80M} & \textbf{90M} & \textbf{100M} \\
                \hline
                    1 & 79.6 & 155.7 & 250.7 & 324 & 396 & 486.4 & 572.5 & 665.7 & 769.4 & 857.3 \\ 
                    2 & 75.1 & 159.7 & 241.7 & 316.3 & 387.4 & 479.2 & 561.4 & 658.8 & 775.9 & 849.3 \\ 
                    3 & 76.4 & 158.9 & 243.4 & 322.5 & 396 & 472 & 576.4 & 659.5 & 776.2 & 852.5 \\ 
                    4 & 79.6 & 156.5 & 244.9 & 320.3 & 391.5 & 483.7 & 574.3 & 664.6 & 759.2 & 850.2 \\ 
                    5 & 77.8 & 160.8 & 247.8 & 322.3 & 392.3 & 484.6 & 560.2 & 668 & 780.6 & 849.6 \\ 
                    6 & 77.8 & 158.2 & 244.9 & 320.5 & 389.8 & 481 & 578.8 & 672.3 & 763.2 & 855.2 \\ 
                    7 & 74.3 & 156.7 & 246.2 & 307.6 & 389.1 & 477.4 & 573.4 & 675.6 & 759.7 & 848.6 \\ 
                    8 & 74.8 & 158.1 & 245.4 & 319.7 & 389.6 & 486 & 562.1 & 657.4 & 761.8 & 857.7 \\ 
                    9 & 72.8 & 163.4 & 245.6 & 321.7 & 402.1 & 499 & 566 & 657 & 766.2 & 851.1 \\ 
                    10 & 78.4 & 160.1 & 247.7 & 320.8 & 401.3 & 473.3 & 573.6 & 660.9 & 772.7 & 849 \\ 
                \hline
                \end{tabularx}
                
                Realizando una comparación entre los tres lenguajes utilizados, se puede observar que los lenguajes C++ y Go tienen un tiempo de ejecución bastante similary que es bajo, mientras que Python es el que toma mas tiempo de ejecución.

                \begin{tikzpicture} [scale = 1.5]
                    \begin{axis}[
                        xlabel=Cantidad de elementos (miles),
                        ylabel=Tiempo de ejecución (milisegundos),
                        xmin=0, xmax=100000,
                        ymin=0, ymax=1000,
                        xtick={10000,20000,30000,40000,50000,60000,70000,80000,90000,100000},
                        xticklabels={,20000,,40000,,60000,,80000,,100000},
                        ytick={0,100,200,300,400,500,600,700,800,900,1000},
                        yticklabels={0,100,200,300,400,500,600,700,800,900,1000}
                                ]
                    \addplot[smooth,mark=*,blue] 
                        plot coordinates {
                            (10000, 5.3)
                            (20000, 11.4)
                            (30000, 17.4)
                            (40000, 23.5)
                            (50000, 30)
                            (60000, 37.3)
                            (70000, 43.6)
                            (80000, 50.6)
                            (90000, 57.1)
                            (100000, 64.5)
                        
                        };
                    \addlegendentry{C++}
                    
                    \addplot[smooth,color=green,mark=x]
                        plot coordinates {
                            (10000, 1.6)
                            (20000, 3.8)
                            (30000, 5.2)
                            (40000, 8.5)
                            (50000, 10.6)
                            (60000, 13.7)
                            (70000, 18.1)
                            (80000, 19.0)
                            (90000, 21.5)
                            (100000, 23.6)
                        };
                    \addlegendentry{Go}
                    
                    \addplot[smooth,color=red,mark=x]
                        plot coordinates {
                            (10000, 76.7)
                            (20000, 158.8)
                            (30000, 245.8)
                            (40000, 319.6)
                            (50000, 393.5)
                            (60000, 482.3)
                            (70000, 569.9)
                            (80000, 663.9)
                            (90000, 768.5)
                            (100000, 852.1)
                        };
                    \addlegendentry{Python}
                    \end{axis}
                    
                \end{tikzpicture}
                
            \end{enumerate}

    \section{Conclusiones}\label{sec:conclusiones}
            Conclusiones aca
    
	\bibliographystyle{apalike}
	\bibliography{bibliography}
    
    \begin{thebibliography}{2}
        \bibitem{cormen2022}
            Thomas H. Cormen (2022), Charles E. Leiserson, Ronald L. Rivest and Clifford Stein, MIT Press
    
        \bibitem{lamport1994}
            Leslie Lamport (1994), Addison
            Wesley, Massachusetts, 2nd ed.
            
    \end{thebibliography}
	
\end{document}